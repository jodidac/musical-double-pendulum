<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Doble P√©ndulo Musical ‚Äî Simulador Audiovisual</title>
  <style>
    :root {
      --bg: #0a0a0a;
      --panel: #1a1a1a;
      --border: #333;
      --accent: #4a9eff;
      --axis: #2b6fff;
      --grid: #121212;
      --text: #ffffff;
      --muted: #888;
      --trace1: #ff6b4a;
      --trace2: #4aff6b;
      --warning: #ff6b4a;
      --success: #4aff6b;
      --audio: #ff9500;
    }
    * { box-sizing: border-box; }
    body { margin: 0; padding: 18px; font-family: Consolas, monospace; background: var(--bg); color: var(--text); }
    .container { display: flex; gap: 18px; min-width: 1200px; align-items: flex-start; }
    .simulation-panel, .controls-panel {
      background: var(--panel);
      border: 2px solid var(--border);
      border-radius: 10px;
      padding: 18px;
      flex-shrink: 0;
    }
    .controls-panel { width: 380px; }
    h3 { margin: 0 0 10px 0; color: var(--accent); font-size: 14px; letter-spacing: 2px; text-transform: uppercase; }
    .audio-section { border: 2px solid var(--audio); border-radius: 8px; padding: 12px; margin: 10px 0; background: #1a0f00; }
    .audio-section h3 { color: var(--audio); margin-bottom: 12px; }
    .status { background:#000; color:var(--accent); padding:10px; border-radius:6px; margin-bottom:10px; font-size:11px; }
    .audio-status { background:#1a0f00; color:var(--audio); border: 1px solid var(--audio); }
    .toolbar { display:flex; gap:8px; margin-bottom:10px; flex-wrap: wrap; }
    button {
      padding: 8px 10px; border: 1px solid var(--accent); background: var(--panel); color: var(--accent);
      border-radius: 6px; cursor: pointer; transition: all .2s; font-family: inherit; font-size: 12px;
    }
    button:hover { background: var(--accent); color: #000; }
    button.audio-btn { border-color: var(--audio); color: var(--audio); }
    button.audio-btn:hover { background: var(--audio); color: #000; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    canvas { background:#000; border:1px solid #444; display:block; max-width:100%; height:auto; cursor:grab; }
    canvas:active { cursor:grabbing; }
    .geometry-info { background:#0a0a2a; color:#99aaff; padding:10px; border-radius:6px; margin-top:10px; font-size:11px; }
    .energy-info { background:#0a2a0a; color:#99ff99; padding:10px; border-radius:6px; margin-top:6px; font-size:11px; }
    .control-group { margin-bottom: 14px; padding-bottom:12px; border-bottom:1px solid #333; }
    .control-group:last-child { border-bottom: none; }
    label { display:block; margin-bottom:6px; font-size:12px; color:#ccc; text-transform:uppercase; letter-spacing:1px; }
    input[type="range"] { width:100%; margin-bottom:6px; accent-color: var(--accent); }
    .audio-control input[type="range"] { accent-color: var(--audio); }
    .value-display { background:#000; color:var(--accent); padding:2px 6px; border-radius:3px; font-size:11px; float:right; }
    .audio-value { color: var(--audio); }
    .is-fullscreen {
      width: 100vw !important; height: 100vh !important; max-width: 100vw !important; max-height: 100vh !important;
      border-radius: 0 !important; margin: 0 !important; padding: 10px !important;
    }
    .physics-note {
      background: #1a1a2a; color: #aabbff; padding: 8px; border-radius: 4px; font-size: 10px;
      border-left: 3px solid var(--accent); margin-top: 8px;
    }
    .audio-note {
      background: #1a0f00; color: #ffbb55; padding: 8px; border-radius: 4px; font-size: 10px;
      border-left: 3px solid var(--audio); margin-top: 8px;
    }
    .frequency-display {
      display: flex; justify-content: space-between; font-size: 10px; color: var(--audio);
      background: #0f0500; padding: 4px 8px; border-radius: 3px; margin-top: 4px;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="simulation-panel" id="simPanel">
      <h3>üéµ Doble P√©ndulo Musical</h3>
      <div class="status" id="status">Estado: Detenido | Energ√≠a: 0.00 J | Tiempo: 0.00 s</div>
      <div class="status audio-status" id="audioStatus">Tonal: Deshabilitado | Percusi√≥n: Deshabilitado | ‚ô™: -- Hz | ü•Å: 0 golpes</div>
      <div class="toolbar">
        <button id="startBtn">‚ñ∂</button>
        <button id="stopBtn">‚èπ</button>
        <button id="resetBtn">‚ü≤</button>
        <button id="clearBtn">üóë</button>
        <button id="tonalBtn" class="audio-btn">‚ô™</button>
        <button id="percussionBtn" class="audio-btn">ü•Å</button>
        <button id="fsBtn">‚õ∂</button>
      </div>
      <canvas id="pendulumCanvas" width="680" height="540"></canvas>
      <div class="geometry-info" id="geometryInfo">
        <strong>Estado F√≠sico:</strong><br />
        Configuraci√≥n inicial: Posici√≥n vertical hacia arriba (12h)<br />
        Estado: Equilibrio inestable<br />
        Energ√≠a: M√°ximo potencial disponible
      </div>
      <div class="energy-info" id="energyInfo">
        <strong>Conservaci√≥n de Energ√≠a:</strong><br />
        Deriva energ√©tica: 0.0% | Estado: CORRECTO
      </div>
    </div>

    <div class="controls-panel">
      <h3>Par√°metros F√≠sicos</h3>
      <div class="control-group">
        <label>Balance de Longitudes <span class="value-display" id="balanceDisplay">0.0</span></label>
        <input type="range" id="balance" min="-1.0" max="1.0" step="0.05" value="0.0"/>
        <div style="font-size: 10px; color: #888; margin-top: 4px;">
          ‚Üê L1 mayor | L1 = L2 (centro) | L2 mayor ‚Üí
        </div>
        <div style="font-size: 10px; color: #4a9eff; margin-top: 2px;">
          L1: <span id="l1Value">1.5</span>m | L2: <span id="l2Value">1.5</span>m
        </div>
      </div>
      <div class="control-group">
        <label>Masa P√©ndulo 1 (kg) <span class="value-display" id="m1Display">1.0</span></label>
        <input type="range" id="m1" min="0.2" max="5.0" step="0.1" value="1.0"/>
        <label>Masa P√©ndulo 2 (kg) <span class="value-display" id="m2Display">0.5</span></label>
        <input type="range" id="m2" min="0.2" max="5.0" step="0.1" value="0.5"/>
      </div>
      <div class="control-group">
        <label>Gravedad (m/s¬≤) <span class="value-display" id="gDisplay">14.81</span></label>
        <input type="range" id="g" min="0.1" max="20.0" step="0.1" value="14.81"/>
        <label>Fricci√≥n/Amortiguamiento <span class="value-display" id="dampingDisplay">0</span></label>
        <input type="range" id="damping" min="0" max="2.0" step="0.01" value="0"/>
      </div>
      <div class="control-group">
        <label>Velocidad Angular 1 (rad/s) <span class="value-display" id="w1Display">0.0</span></label>
        <input type="range" id="w1" min="-6.0" max="6.0" step="0.1" value="0.0"/>
        <label>Velocidad Angular 2 (rad/s) <span class="value-display" id="w2Display">0.0</span></label>
        <input type="range" id="w2" min="-6.0" max="6.0" step="0.1" value="0.0"/>
      </div>

      <!-- SECCI√ìN DE AUDIO -->
      <div class="audio-section">
        <h3>üéµ Configuraci√≥n de Audio</h3>
        <div class="control-group audio-control">
          <label>Volumen General <span class="value-display audio-value" id="volumeDisplay">0.3</span></label>
          <input type="range" id="volume" min="0" max="1.0" step="0.05" value="0.3"/>
          
          <label>Frecuencia Base - P√©ndulo 1 (Hz) <span class="value-display audio-value" id="freq1Display">440</span></label>
          <input type="range" id="freq1" min="200" max="1000" step="10" value="440"/>
          
          <label>Frecuencia Base - P√©ndulo 2 (Hz) <span class="value-display audio-value" id="freq2Display">550</span></label>
          <input type="range" id="freq2" min="200" max="1000" step="10" value="550"/>
          
          <label>Sensibilidad <span class="value-display audio-value" id="sensitivityDisplay">2.0</span></label>
          <input type="range" id="sensitivity" min="0.5" max="5.0" step="0.1" value="2.0"/>
          
          <div class="frequency-display" id="liveFreqs">
            <span>‚ô™1: -- Hz</span>
            <span>‚ô™2: -- Hz</span>
            <span>Vol: --%</span>
          </div>
        </div>
        
        <div class="audio-note">
          <strong>üéº Sonificaci√≥n:</strong> Las velocidades angulares œâ‚ÇÅ y œâ‚ÇÇ se convierten en frecuencias de sonido. Mayor velocidad = tono m√°s agudo. El acoplamiento entre p√©ndulos genera armon√≠as complejas.
        </div>
      </div>

      <!-- SECCI√ìN DE PERCUSI√ìN -->
      <div class="audio-section">
        <h3>ü•Å Modo Percusi√≥n</h3>
        <div class="control-group audio-control">
          
          <label>Volumen Percusi√≥n <span class="value-display audio-value" id="percVolumeDisplay">0.5</span></label>
          <input type="range" id="percVolume" min="0" max="1.0" step="0.05" value="0.5"/>
          
          <label>Umbral de Pico <span class="value-display audio-value" id="thresholdDisplay">1.0</span></label>
          <input type="range" id="threshold" min="0.2" max="3.0" step="0.1" value="1.0"/>
          
          <label>Cooldown (ms) <span class="value-display audio-value" id="cooldownDisplay">100</span></label>
          <input type="range" id="cooldown" min="50" max="500" step="10" value="100"/>
          
          <div class="frequency-display" id="percStatus">
            <span id="kick-status">ü•Å Bombo: Esperando</span>
            <span id="snare-status">üîî Caja: Esperando</span>
          </div>
        </div>
        
        <div class="audio-note">
          <strong>ü•Å Percusi√≥n:</strong> Detecta picos de velocidad angular y los convierte en golpes de bater√≠a. P√©ndulo 1 ‚Üí Bombo grave. P√©ndulo 2 ‚Üí Caja aguda. Experimenta los patrones r√≠tmicos del caos.
        </div>
      </div>

      <div class="control-group">
        <label>Œît integraci√≥n (s) <span class="value-display" id="dtDisplay">0.005</span></label>
        <input type="range" id="dt" min="0.001" max="0.200" step="0.001" value="0.020"/>
      </div>
      
      <div class="info" style="font-size:11px;color:#aaa;margin-top:6px">
        ‚Ä¢ Œ∏=0 apunta hacia abajo, Œ∏=œÄ hacia arriba<br>
        ‚Ä¢ Posici√≥n inicial: Vertical hacia arriba (equilibrio inestable)<br>
        ‚Ä¢ <span style="color:var(--success)">NUEVO:</span> S√≠ntesis de audio en tiempo real<br>
        ‚Ä¢ <span style="color:var(--audio)">üéµ Audio:</span> Experimenta el caos a trav√©s del sonido
      </div>
    </div>
  </div>

  <script>
    class MusicalDoublePendulum {
      constructor(canvasId, panelId) {
        this.canvas = document.getElementById(canvasId);
        this.ctx = this.canvas.getContext('2d');
        this.panel = document.getElementById(panelId);
        this.width = this.canvas.width;
        this.height = this.canvas.height;

        // Origen en el centro del marco
        this.originX = this.width / 2;
        this.originY = this.height / 2;

        // Par√°metros f√≠sicos
        this.l1 = 1.5; this.l2 = 1.5;
        this.balance = 0.0; // -1 a 1, donde 0 es equilibrio
        this.m1 = 1.0; this.m2 = 1.0;
        this.g = 9.81;
        this.damping = 0.1;

        // Estado - Posici√≥n inicial vertical hacia ARRIBA (12h del reloj)
        this.theta1 = Math.PI;  // P√©ndulo 1 apuntando hacia arriba (180¬∞)
        this.theta2 = 0.01;      // P√©ndulo 2 alineado con el 1 (tambi√©n hacia arriba)
        this.omega1 = 0.0; this.omega2 = 0.0;

        // Simulaci√≥n
        this.running = false;
        this.time = 0;
        this.dt = 0.005;

        // Escala autom√°tica
        this.scale = 100;

        // Trazas
        this.trace1 = [];
        this.trace2 = [];
        this.maxTraceLength = 3000;

        // Interacci√≥n
        this.dragging = false;
        this.dragTarget = null;

        // Monitoreo de energ√≠a
        this.initialEnergy = 0;
        this.currentEnergy = 0;
        this.maxEnergyDrift = 0;
        this.energyHistory = [];
        this.singularityCount = 0;

        // üéµ SISTEMA DE AUDIO
        this.audioContext = null;
        this.oscillator1 = null;
        this.oscillator2 = null;
        this.gainNode1 = null;
        this.gainNode2 = null;
        this.masterGain = null;
        this.audioEnabled = false;
        
        // ü•Å SISTEMA DE PERCUSI√ìN
        this.percussionEnabled = false;
        this.kickBuffer = null;
        this.snareBuffer = null;
        this.percussionGain = null;
        this.kickGainNode = null;
        this.snareGainNode = null;
        
        // Detecci√≥n de picos
        this.lastOmega1 = 0;
        this.lastOmega2 = 0;
        this.omega1Trend = 0; // 1: creciendo, -1: decreciendo, 0: estable
        this.omega2Trend = 0;
        this.lastTrigger1 = 0; // Tiempo del √∫ltimo trigger (cooldown)
        this.lastTrigger2 = 0;
        this.triggerCooldown = 0.1; // 100ms m√≠nimo entre golpes
        
        // Par√°metros de audio
        this.baseFreq1 = 440; // La (A4)
        this.baseFreq2 = 550; // Do# aproximadamente
        this.volume = 0.3;
        this.sensitivity = 2.0;
        
        // Par√°metros de percusi√≥n
        this.percussionVolume = 0.5;
        this.peakThreshold = 1.0; // Umbral m√≠nimo para detectar pico
        
        // Frecuencias actuales para display
        this.currentFreq1 = 0;
        this.currentFreq2 = 0;
        
        // Contadores de percusi√≥n
        this.kickCount = 0;
        this.snareCount = 0;

        this.setupEventListeners();
        this.updateLengthsFromBalance(); // Initialize l1 and l2 from balance
        this.updateControls();
        this.updateCanvasMetrics();
        this.initialEnergy = this.computeEnergy();
        this.draw();
      }

      // ü•Å CREAR SONIDOS DE PERCUSI√ìN SINT√âTICOS
      createPercussionSounds() {
        if (!this.audioContext) return;
        
        // ü•Å KICK DRUM (Bombo)
        const kickLength = 0.5;
        const kickBuffer = this.audioContext.createBuffer(1, kickLength * this.audioContext.sampleRate, this.audioContext.sampleRate);
        const kickData = kickBuffer.getChannelData(0);
        
        for (let i = 0; i < kickData.length; i++) {
          const t = i / this.audioContext.sampleRate;
          // Envolvente exponencial + oscilaci√≥n de baja frecuencia
          const envelope = Math.exp(-t * 15); // Decaimiento r√°pido
          const freq = 60 * (1 - t * 0.8); // Frequency sweep descendente
          const sample = Math.sin(2 * Math.PI * freq * t) * envelope;
          
          // Agregar algo de ruido para textura
          const noise = (Math.random() - 0.5) * 0.1 * envelope;
          kickData[i] = sample + noise;
        }
        this.kickBuffer = kickBuffer;
        
        // üîî SNARE DRUM (Caja)
        const snareLength = 0.2;
        const snareBuffer = this.audioContext.createBuffer(1, snareLength * this.audioContext.sampleRate, this.audioContext.sampleRate);
        const snareData = snareBuffer.getChannelData(0);
        
        for (let i = 0; i < snareData.length; i++) {
          const t = i / this.audioContext.sampleRate;
          // Envolvente m√°s corta y aguda
          const envelope = Math.exp(-t * 30);
          
          // Combinaci√≥n de tono y ruido (caracter√≠stico de la caja)
          const tone = Math.sin(2 * Math.PI * 200 * t) * 0.3;
          const noise = (Math.random() - 0.5) * 0.7; // M√°s ruido que tono
          
          snareData[i] = (tone + noise) * envelope;
        }
        this.snareBuffer = snareBuffer;
      }

      // ü•Å REPRODUCIR SONIDO DE PERCUSI√ìN
      playPercussion(type) {
        if (!this.percussionEnabled || !this.audioContext) return;
        
        const now = this.audioContext.currentTime;
        const source = this.audioContext.createBufferSource();
        const gainNode = this.audioContext.createGain();
        
        if (type === 'kick' && this.kickBuffer) {
          source.buffer = this.kickBuffer;
          gainNode.gain.setValueAtTime(this.percussionVolume * 0.8, now); // Bombo m√°s fuerte
          this.kickCount++;
        } else if (type === 'snare' && this.snareBuffer) {
          source.buffer = this.snareBuffer;
          gainNode.gain.setValueAtTime(this.percussionVolume * 0.6, now); // Caja m√°s sutil
          this.snareCount++;
        } else {
          return;
        }
        
        source.connect(gainNode);
        gainNode.connect(this.audioContext.destination);
        source.start(now);
        
        // Auto-disconnect despu√©s del sonido
        setTimeout(() => {
          try {
            source.disconnect();
            gainNode.disconnect();
          } catch (e) {}
        }, 600);
      }

      // ü•Å DETECTAR PICOS DE VELOCIDAD ANGULAR
      detectPeaks() {
        if (!this.percussionEnabled) return;
        
        const now = this.audioContext ? this.audioContext.currentTime : this.time;
        const currentTime = now;
        
        // Calcular tendencias de velocidad angular
        const omega1Diff = this.omega1 - this.lastOmega1;
        const omega2Diff = this.omega2 - this.lastOmega2;
        
        const newTrend1 = omega1Diff > 0.01 ? 1 : (omega1Diff < -0.01 ? -1 : 0);
        const newTrend2 = omega2Diff > 0.01 ? 1 : (omega2Diff < -0.01 ? -1 : 0);
        
        // Detectar pico: cuando la tendencia cambia de creciente a decreciente
        // Y la velocidad angular supera el umbral
        if (this.omega1Trend === 1 && newTrend1 === -1 && 
            Math.abs(this.omega1) > this.peakThreshold &&
            currentTime - this.lastTrigger1 > this.triggerCooldown) {
          
          this.playPercussion('kick');
          this.lastTrigger1 = currentTime;
          this.updatePercussionStatus('kick', true);
        }
        
        if (this.omega2Trend === 1 && newTrend2 === -1 && 
            Math.abs(this.omega2) > this.peakThreshold &&
            currentTime - this.lastTrigger2 > this.triggerCooldown) {
          
          this.playPercussion('snare');
          this.lastTrigger2 = currentTime;
          this.updatePercussionStatus('snare', true);
        }
        
        // Actualizar estados
        this.lastOmega1 = this.omega1;
        this.lastOmega2 = this.omega2;
        this.omega1Trend = newTrend1;
        this.omega2Trend = newTrend2;
      }

      // ü•Å ACTUALIZAR STATUS VISUAL DE PERCUSI√ìN
      updatePercussionStatus(type, triggered) {
        const kickStatus = document.getElementById('kick-status');
        const snareStatus = document.getElementById('snare-status');
        
        if (type === 'kick' && triggered && kickStatus) {
          kickStatus.textContent = 'ü•Å Bombo: ¬°GOLPE!';
          kickStatus.style.color = '#ff6b4a';
          setTimeout(() => {
            kickStatus.textContent = 'ü•Å Bombo: Esperando';
            kickStatus.style.color = '';
          }, 150);
        }
        
        if (type === 'snare' && triggered && snareStatus) {
          snareStatus.textContent = 'üîî Caja: ¬°GOLPE!';
          snareStatus.style.color = '#4aff6b';
          setTimeout(() => {
            snareStatus.textContent = 'üîî Caja: Esperando';
            snareStatus.style.color = '';
          }, 150);
        }
      }

      // üéµ INICIALIZACI√ìN DEL SISTEMA DE AUDIO ACTUALIZADA
      async initAudio() {
        try {
          if (!this.audioContext) {
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
          }
          
          // Solo inicializar osciladores si no existen ya
          if (!this.masterGain) {
            // Crear nodo de ganancia maestro
            this.masterGain = this.audioContext.createGain();
            this.masterGain.connect(this.audioContext.destination);
            this.masterGain.gain.setValueAtTime(this.volume, this.audioContext.currentTime);
          }
          
          // Solo crear osciladores para modo tonal si no existen
          if (!this.oscillator1 && !this.audioEnabled) {
            this.oscillator1 = this.audioContext.createOscillator();
            this.gainNode1 = this.audioContext.createGain();
            this.oscillator1.connect(this.gainNode1);
            this.gainNode1.connect(this.masterGain);
            
            this.oscillator2 = this.audioContext.createOscillator();
            this.gainNode2 = this.audioContext.createGain();
            this.oscillator2.connect(this.gainNode2);
            this.gainNode2.connect(this.masterGain);
            
            // Configurar tipo de onda (suena m√°s musical)
            this.oscillator1.type = 'sine';
            this.oscillator2.type = 'triangle';
            
            // Iniciar frecuencias base
            this.oscillator1.frequency.setValueAtTime(this.baseFreq1, this.audioContext.currentTime);
            this.oscillator2.frequency.setValueAtTime(this.baseFreq2, this.audioContext.currentTime);
            
            // Iniciar con volumen bajo
            this.gainNode1.gain.setValueAtTime(0, this.audioContext.currentTime);
            this.gainNode2.gain.setValueAtTime(0, this.audioContext.currentTime);
            
            // Iniciar osciladores
            this.oscillator1.start();
            this.oscillator2.start();
            
            this.audioEnabled = true;
          }
          
          return true;
        } catch (error) {
          console.error('Error inicializando audio:', error);
          return false;
        }
      }

      // üéµ ACTUALIZAR SONIDO BASADO EN MOVIMIENTO
      updateAudio() {
        if (!this.audioEnabled || !this.audioContext) return;
        
        const now = this.audioContext.currentTime;
        
        // Mapear velocidades angulares a frecuencias
        // |œâ| * sensitivity da el factor de multiplicaci√≥n de frecuencia
        const freqMult1 = 1 + Math.abs(this.omega1) * this.sensitivity * 0.1;
        const freqMult2 = 1 + Math.abs(this.omega2) * this.sensitivity * 0.1;
        
        this.currentFreq1 = this.baseFreq1 * freqMult1;
        this.currentFreq2 = this.baseFreq2 * freqMult2;
        
        // Limitar frecuencias a rango audible agradable
        this.currentFreq1 = Math.max(100, Math.min(2000, this.currentFreq1));
        this.currentFreq2 = Math.max(100, Math.min(2000, this.currentFreq2));
        
        // Actualizar frecuencias suavemente
        this.oscillator1.frequency.setTargetAtTime(this.currentFreq1, now, 0.01);
        this.oscillator2.frequency.setTargetAtTime(this.currentFreq2, now, 0.01);
        
        // Volumen basado en velocidad angular (m√°s movimiento = m√°s volumen)
        const vol1 = Math.min(0.5, Math.abs(this.omega1) * 0.1) * this.volume;
        const vol2 = Math.min(0.5, Math.abs(this.omega2) * 0.1) * this.volume;
        
        this.gainNode1.gain.setTargetAtTime(vol1, now, 0.01);
        this.gainNode2.gain.setTargetAtTime(vol2, now, 0.01);
      }

      // ü•Å DESACTIVAR PERCUSI√ìN
      stopPercussion() {
        this.percussionEnabled = false;
        this.kickBuffer = null;
        this.snareBuffer = null;
        
        // Solo cerrar el contexto si tampoco est√° activo el modo tonal
        if (!this.audioEnabled && this.audioContext) {
          try {
            this.audioContext.close();
            this.audioContext = null;
            this.masterGain = null;
          } catch (error) {
            console.warn('Error cerrando contexto de audio:', error);
          }
        }
      }

      // üéµ DESACTIVAR AUDIO TONAL
      stopAudio() {
        if (this.oscillator1 && this.oscillator2 && this.audioEnabled) {
          try {
            this.oscillator1.stop();
            this.oscillator2.stop();
            this.oscillator1 = null;
            this.oscillator2 = null;
            this.gainNode1 = null;
            this.gainNode2 = null;
          } catch (error) {
            console.warn('Error deteniendo osciladores:', error);
          }
        }
        this.audioEnabled = false;
        
        // Solo cerrar el contexto si tampoco est√° activo el modo percusi√≥n
        if (!this.percussionEnabled && this.audioContext) {
          try {
            this.audioContext.close();
            this.audioContext = null;
            this.masterGain = null;
          } catch (error) {
            console.warn('Error cerrando contexto de audio:', error);
          }
        }
      }

      setupEventListeners() {
        const controls = ['balance','m1','m2','g','damping','w1','w2','dt','volume','freq1','freq2','sensitivity','percVolume','threshold','cooldown'];
        controls.forEach(id => {
          document.getElementById(id).addEventListener('input', (e) => {
            const v = parseFloat(e.target.value);
            if (id === 'balance') {
              this.balance = v;
              this.updateLengthsFromBalance();
            } else if (id === 'w1') this.omega1 = v;
            else if (id === 'w2') this.omega2 = v;
            else if (id === 'dt') this.dt = v;
            else if (id === 'volume') this.volume = v;
            else if (id === 'freq1') this.baseFreq1 = v;
            else if (id === 'freq2') this.baseFreq2 = v;
            else if (id === 'sensitivity') this.sensitivity = v;
            else if (id === 'percVolume') this.percussionVolume = v;
            else if (id === 'threshold') this.peakThreshold = v;
            else if (id === 'cooldown') this.triggerCooldown = v / 1000; // Convertir ms a segundos
            else this[id] = v;
            
            this.updateControls();
            if (id === 'balance') this.updateScale();
            
            // Actualizar audio si est√° activo
            if (this.audioEnabled && (id === 'volume' || id === 'freq1' || id === 'freq2' || id === 'sensitivity')) {
              if (this.masterGain) {
                this.masterGain.gain.setTargetAtTime(this.volume, this.audioContext.currentTime, 0.1);
              }
            }
            
            if (!this.running) {
              this.initialEnergy = this.computeEnergy();
              this.maxEnergyDrift = 0;
              this.energyHistory = [];
            }
            if (!this.running) this.draw();
          });
        });

        document.getElementById('startBtn').addEventListener('click', () => this.start());
        document.getElementById('stopBtn').addEventListener('click', () => this.stop());
        document.getElementById('resetBtn').addEventListener('click', () => this.reset());
        document.getElementById('clearBtn').addEventListener('click', () => this.clearTraces());
        document.getElementById('fsBtn').addEventListener('click', () => this.toggleFullscreen());
        
        // üéµ BOT√ìN DE AUDIO TONAL
        document.getElementById('tonalBtn').addEventListener('click', async () => {
          const btn = document.getElementById('tonalBtn');
          if (!this.audioEnabled) {
            const success = await this.initAudio();
            if (success) {
              btn.textContent = 'üîá';
              btn.style.background = '#ff9500';
              btn.style.color = '#000';
            }
          } else {
            this.stopAudio();
            btn.textContent = '‚ô™';
            btn.style.background = '';
            btn.style.color = '#ff9500';
          }
        });
        
        // ü•Å BOT√ìN DE PERCUSI√ìN
        document.getElementById('percussionBtn').addEventListener('click', async () => {
          const btn = document.getElementById('percussionBtn');
          if (!this.percussionEnabled) {
            // Inicializar audio si no est√° activo
            if (!this.audioContext) {
              const success = await this.initAudio();
              if (!success) return;
            }
            
            // Crear sonidos de percusi√≥n
            this.createPercussionSounds();
            this.percussionEnabled = true;
            btn.textContent = 'üîá';
            btn.style.background = '#ff9500';
            btn.style.color = '#000';
          } else {
            this.stopPercussion();
            btn.textContent = 'ü•Å';
            btn.style.background = '';
            btn.style.color = '#ff9500';
          }
        });

        this.canvas.addEventListener('mousedown', (e) => this.onMouseDown(e));
        this.canvas.addEventListener('mousemove', (e) => this.onMouseMove(e));
        this.canvas.addEventListener('mouseup',   () => this.onMouseUp());
        this.canvas.addEventListener('mouseleave',() => this.onMouseUp());

        window.addEventListener('resize', () => this.onResize());
        document.addEventListener('fullscreenchange', () => this.onFullscreenChange());
      }

      updateLengthsFromBalance() {
        // Longitud base cuando balance = 0
        const baseLength = 1.5;
        const maxDelta = 1.0; // Variaci√≥n m√°xima
        
        // Cuando balance = 0, ambos son iguales
        // Cuando balance = -1, L1 es m√°ximo y L2 es m√≠nimo
        // Cuando balance = 1, L1 es m√≠nimo y L2 es m√°ximo
        this.l1 = baseLength - (this.balance * maxDelta);
        this.l2 = baseLength + (this.balance * maxDelta);
        
        // Asegurar l√≠mites m√≠nimos
        this.l1 = Math.max(0.5, Math.min(2.5, this.l1));
        this.l2 = Math.max(0.5, Math.min(2.5, this.l2));
      }

      updateControls() {
        const set = (id, v, digits=2) => document.getElementById(id).textContent = v.toFixed(digits);
        set('balanceDisplay', this.balance, 2);
        document.getElementById('l1Value').textContent = this.l1.toFixed(2);
        document.getElementById('l2Value').textContent = this.l2.toFixed(2);
        set('m1Display', this.m1, 2);
        set('m2Display', this.m2, 2);
        set('gDisplay', this.g, 2);
        set('dampingDisplay', this.damping, 2);
        set('w1Display', this.omega1, 2);
        set('w2Display', this.omega2, 2);
        set('dtDisplay', this.dt, 3);
        
        // üéµ CONTROLES DE AUDIO
        set('volumeDisplay', this.volume, 2);
        document.getElementById('freq1Display').textContent = this.baseFreq1.toFixed(0);
        document.getElementById('freq2Display').textContent = this.baseFreq2.toFixed(0);
        set('sensitivityDisplay', this.sensitivity, 1);
        
        // ü•Å CONTROLES DE PERCUSI√ìN
        set('percVolumeDisplay', this.percussionVolume, 2);
        set('thresholdDisplay', this.peakThreshold, 1);
        document.getElementById('cooldownDisplay').textContent = (this.triggerCooldown * 1000).toFixed(0);
      }

      toggleFullscreen() {
        const elem = this.panel;
        if (!document.fullscreenElement) elem.requestFullscreen && elem.requestFullscreen();
        else document.exitFullscreen && document.exitFullscreen();
      }
      onFullscreenChange() {
        if (document.fullscreenElement === this.panel) {
          this.panel.classList.add('is-fullscreen');
          this.resizeCanvasToPanel();
        } else {
          this.panel.classList.remove('is-fullscreen');
          this.canvas.width = 680; this.canvas.height = 540;
          this.updateCanvasMetrics();
        }
      }
      onResize() {
        if (document.fullscreenElement === this.panel) this.resizeCanvasToPanel();
      }
      resizeCanvasToPanel() {
        const rect = this.panel.getBoundingClientRect();
        const reserved = 220;
        const newW = Math.max(320, Math.floor(rect.width - 20));
        const newH = Math.max(300, Math.floor(rect.height - reserved));
        this.canvas.width = newW;
        this.canvas.height = newH;
        this.updateCanvasMetrics();
      }

      getMousePos(e) {
        const r = this.canvas.getBoundingClientRect();
        return { x: e.clientX - r.left, y: e.clientY - r.top };
      }
      onMouseDown(e) {
        if (this.running) return;
        const mouse = this.getMousePos(e);
        const p1 = this.getPendulumPosition(1);
        const p2 = this.getPendulumPosition(2);
        const d1 = Math.hypot(mouse.x - p1.x, mouse.y - p1.y);
        const d2 = Math.hypot(mouse.x - p2.x, mouse.y - p2.y);
        if (d1 < 20) { this.dragging = true; this.dragTarget = 1; }
        else if (d2 < 20) { this.dragging = true; this.dragTarget = 2; }
      }
      onMouseMove(e) {
        if (!this.dragging || this.running) return;
        const mouse = this.getMousePos(e);
        if (this.dragTarget === 1) {
          const dx = mouse.x - this.originX;
          const dy = mouse.y - this.originY;
          this.theta1 = Math.atan2(dx, dy);
        } else if (this.dragTarget === 2) {
          const p1 = this.getPendulumPosition(1);
          const dx = mouse.x - p1.x;
          const dy = mouse.y - p1.y;
          const absTheta2 = Math.atan2(dx, dy);
          this.theta2 = absTheta2 - this.theta1;
        }
        this.initialEnergy = this.computeEnergy();
        this.maxEnergyDrift = 0;
        this.energyHistory = [];
        this.draw();
      }
      onMouseUp() { this.dragging = false; this.dragTarget = null; }

      updateCanvasMetrics() {
        this.width = this.canvas.width; this.height = this.canvas.height;
        this.originX = this.width / 2; this.originY = this.height / 2;
        this.updateScale();
        if (!this.running) this.draw();
      }
      updateScale() {
        const marginFactor = 0.9;
        const halfMin = 0.5 * Math.min(this.width, this.height) * marginFactor;
        const totalLen = (this.l1 + this.l2);
        this.scale = totalLen > 0 ? halfMin / totalLen : 100;
      }

      getPendulumPosition(n) {
        if (n === 1) {
          return {
            x: this.originX + this.l1 * this.scale * Math.sin(this.theta1),
            y: this.originY + this.l1 * this.scale * Math.cos(this.theta1)
          };
        } else {
          const p1 = this.getPendulumPosition(1);
          return {
            x: p1.x + this.l2 * this.scale * Math.sin(this.theta1 + this.theta2),
            y: p1.y + this.l2 * this.scale * Math.cos(this.theta1 + this.theta2)
          };
        }
      }

      accelerations() {
        const m1 = this.m1, m2 = this.m2, l1 = this.l1, l2 = this.l2, g = this.g;
        const th1 = this.theta1, th2 = this.theta2, w1 = this.omega1, w2 = this.omega2;
        const s12 = Math.sin(th1 - th2);
        const c12 = Math.cos(th1 - th2);
        const denom = (2*m1 + m2 - m2 * Math.cos(2*th1 - 2*th2));

        const MIN_DENOM = 1e-8;
        if (Math.abs(denom) < MIN_DENOM) {
          this.singularityCount++;
          return { 
            a1: -0.1 * w1 - 0.5 * th1, 
            a2: -0.1 * w2 - 0.5 * th2 
          };
        }

        const num1 =
          -g * (2*m1 + m2) * Math.sin(th1)
          - m2 * g * Math.sin(th1 - 2*th2)
          - 2 * s12 * m2 * ( w2*w2*l2 + w1*w1*l1 * c12 );
        let a1 = num1 / (l1 * denom);

        const num2 =
          2 * s12 * ( w1*w1*l1*(m1 + m2)
                    + g*(m1 + m2) * Math.cos(th1)
                    + w2*w2*l2*m2 * c12 );
        let a2 = num2 / (l2 * denom);

        // Amortiguamiento f√≠sicamente realista
        if (this.damping > 0) {
          const x1 = l1 * Math.sin(th1);
          const y1 = l1 * Math.cos(th1);
          const x2 = x1 + l2 * Math.sin(th1 + th2);
          const y2 = y1 + l2 * Math.cos(th1 + th2);
          
          const vx1 = l1 * w1 * Math.cos(th1);
          const vy1 = -l1 * w1 * Math.sin(th1);
          const vx2 = vx1 + l2 * (w1 + w2) * Math.cos(th1 + th2);
          const vy2 = vy1 - l2 * (w1 + w2) * Math.sin(th1 + th2);
          
          const v1_sq = vx1*vx1 + vy1*vy1;
          const v2_sq = vx2*vx2 + vy2*vy2;
          
          const drag_coeff = this.damping * 0.05;
          
          if (v1_sq > 1e-6) {
            const drag_torque1 = -drag_coeff * v1_sq * Math.sign(w1) / l1;
            a1 += drag_torque1;
          }
          
          if (v2_sq > 1e-6) {
            const drag_torque2 = -drag_coeff * v2_sq * Math.sign(w2) / l2;
            a2 += drag_torque2;
          }
          
          const joint_friction = this.damping * 0.3;
          a1 -= joint_friction * (w1 + 0.5 * th1);
          a2 -= joint_friction * (w2 + 0.5 * th2);
          
          if (this.damping > 1.0) {
            const high_damping = (this.damping - 1.0) * 2.0;
            a1 -= high_damping * w1;
            a2 -= high_damping * w2;
          }
        }

        return { a1, a2 };
      }

      rk4Step(dt) {
        const state = () => ({
          th1: this.theta1, th2: this.theta2,
          w1: this.omega1, w2: this.omega2
        });
        const deriv = (th1, th2, w1, w2) => {
          const save_th1 = this.theta1, save_th2 = this.theta2, save_w1 = this.omega1, save_w2 = this.omega2;
          this.theta1 = th1; this.theta2 = th2; this.omega1 = w1; this.omega2 = w2;
          const { a1, a2 } = this.accelerations();
          this.theta1 = save_th1; this.theta2 = save_th2; this.omega1 = save_w1; this.omega2 = save_w2;
          return { dth1: w1, dth2: w2, dw1: a1, dw2: a2 };
        };

        const s0 = state();
        const k1 = deriv(s0.th1, s0.th2, s0.w1, s0.w2);
        const k2 = deriv(s0.th1 + 0.5*dt*k1.dth1, s0.th2 + 0.5*dt*k1.dth2, s0.w1 + 0.5*dt*k1.dw1, s0.w2 + 0.5*dt*k1.dw2);
        const k3 = deriv(s0.th1 + 0.5*dt*k2.dth1, s0.th2 + 0.5*dt*k2.dth2, s0.w1 + 0.5*dt*k2.dw1, s0.w2 + 0.5*dt*k2.dw2);
        const k4 = deriv(s0.th1 + dt*k3.dth1, s0.th2 + dt*k3.dth2, s0.w1 + dt*k3.dw1, s0.w2 + dt*k3.dw2);

        this.theta1 += (dt/6)*(k1.dth1 + 2*k2.dth1 + 2*k3.dth1 + k4.dth1);
        this.theta2 += (dt/6)*(k1.dth2 + 2*k2.dth2 + 2*k3.dth2 + k4.dth2);
        this.omega1 += (dt/6)*(k1.dw1  + 2*k2.dw1  + 2*k3.dw1  + k4.dw1 );
        this.omega2 += (dt/6)*(k1.dw2  + 2*k2.dw2  + 2*k3.dw2  + k4.dw2 );
      }

      update() {
        if (!this.running) return;
        
        this.rk4Step(this.dt);

        // üéµ ACTUALIZAR AUDIO
        this.updateAudio();

        // ü•Å DETECTAR PICOS PARA PERCUSI√ìN
        this.detectPeaks();

        // Trazas
        const p1 = this.getPendulumPosition(1);
        const p2 = this.getPendulumPosition(2);
        this.trace1.push({x: p1.x, y: p1.y});
        this.trace2.push({x: p2.x, y: p2.y});
        if (this.trace1.length > this.maxTraceLength) this.trace1.shift();
        if (this.trace2.length > this.maxTraceLength) this.trace2.shift();

        // Monitoreo de energ√≠a
        this.currentEnergy = this.computeEnergy();
        this.energyHistory.push(this.currentEnergy);
        if (this.energyHistory.length > 1000) this.energyHistory.shift();
        
        const energyDrift = Math.abs(this.currentEnergy - this.initialEnergy);
        this.maxEnergyDrift = Math.max(this.maxEnergyDrift, energyDrift);

        this.time += this.dt;
        this.updateStatus();
      }

      computeEnergy() {
        // Coordenadas en metros
        const x1 = this.l1 * Math.sin(this.theta1);
        const y1 = this.l1 * Math.cos(this.theta1);
        const x2 = x1 + this.l2 * Math.sin(this.theta1 + this.theta2);
        const y2 = y1 + this.l2 * Math.cos(this.theta1 + this.theta2);

        // Velocidades
        const vx1 = this.l1 * this.omega1 * Math.cos(this.theta1);
        const vy1 = -this.l1 * this.omega1 * Math.sin(this.theta1);
        const vx2 = vx1 + this.l2 * (this.omega1 + this.omega2) * Math.cos(this.theta1 + this.theta2);
        const vy2 = vy1 - this.l2 * (this.omega1 + this.omega2) * Math.sin(this.theta1 + this.theta2);

        // Energ√≠a cin√©tica
        const T = 0.5*this.m1*(vx1*vx1 + vy1*vy1) + 0.5*this.m2*(vx2*vx2 + vy2*vy2);
        
        // Energ√≠a potencial corregida
        const V = this.m1*this.g*this.l1*(1-Math.cos(this.theta1)) + 
                  this.m2*this.g*(this.l1*(1-Math.cos(this.theta1)) + 
                                  this.l2*(1-Math.cos(this.theta1+this.theta2)));
        
        return T + V;
      }

      updateStatus() {
        const status = document.getElementById('status');
        const state = this.running ? 'Ejecutando' : 'Detenido';
        status.textContent = `Estado: ${state} | Energ√≠a: ${this.currentEnergy.toFixed(3)} J | Tiempo: ${this.time.toFixed(2)} s`;
        
        // üéµ STATUS DE AUDIO
        const audioStatus = document.getElementById('audioStatus');
        const tonalState = this.audioEnabled ? 'Activo' : 'Deshabilitado';
        const percState = this.percussionEnabled ? 'Activo' : 'Deshabilitado';
        const freq1Str = this.audioEnabled ? this.currentFreq1.toFixed(0) : '--';
        const freq2Str = this.audioEnabled ? this.currentFreq2.toFixed(0) : '--';
        const totalBeats = this.kickCount + this.snareCount;
        audioStatus.textContent = `Tonal: ${tonalState} | Percusi√≥n: ${percState} | ‚ô™: ${freq1Str}/${freq2Str} Hz | ü•Å: ${totalBeats} golpes`;
        
        // üéµ DISPLAY DE FRECUENCIAS EN VIVO
        const liveFreqs = document.getElementById('liveFreqs');
        const vol1 = this.audioEnabled ? (Math.min(0.5, Math.abs(this.omega1) * 0.1) * this.volume * 100).toFixed(0) : 0;
        const vol2 = this.audioEnabled ? (Math.min(0.5, Math.abs(this.omega2) * 0.1) * this.volume * 100).toFixed(0) : 0;
        liveFreqs.innerHTML = `
          <span>‚ô™1: ${freq1Str} Hz</span>
          <span>‚ô™2: ${freq2Str} Hz</span>
          <span>Vol: ${Math.max(vol1,vol2)}%</span>
        `;

        // Informaci√≥n sobre conservaci√≥n de energ√≠a
        const energyInfo = document.getElementById('energyInfo');
        const energyDriftPercent = this.initialEnergy !== 0 ? 
          (this.maxEnergyDrift / Math.abs(this.initialEnergy)) * 100 : 0;
        
        let energyStatus = "CORRECTO";
        let statusClass = "energy-info";
        
        if (energyDriftPercent > 1.0) {
          energyStatus = "DERIVA ALTA";
          statusClass = "energy-info warning";
        } else if (energyDriftPercent > 0.1) {
          energyStatus = "DERIVA MENOR";
        }
        
        energyInfo.className = statusClass;
        energyInfo.innerHTML = `
          <strong>Conservaci√≥n de Energ√≠a:</strong><br>
          Inicial: ${this.initialEnergy.toFixed(4)} J | Actual: ${this.currentEnergy.toFixed(4)} J<br>
          Deriva energ√©tica: ${energyDriftPercent.toFixed(3)}% | Estado: ${energyStatus}
          ${this.singularityCount > 0 ? `<br><span style="color:var(--warning)">Singularidades: ${this.singularityCount}</span>` : ''}
        `;

        const geometryInfo = document.getElementById('geometryInfo');
        const totalVel = Math.sqrt(this.omega1*this.omega1 + this.omega2*this.omega2);
        const isNearEquilibrium = Math.abs(this.theta1) < 0.1 && Math.abs(this.theta2) < 0.1 && totalVel < 0.1;
        
        geometryInfo.innerHTML = `
          <strong>Estado F√≠sico:</strong><br>
          Œ∏‚ÇÅ=${this.theta1.toFixed(3)} rad, Œ∏‚ÇÇ=${this.theta2.toFixed(3)} rad<br>
          œâ‚ÇÅ=${this.omega1.toFixed(3)} rad/s, œâ‚ÇÇ=${this.omega2.toFixed(3)} rad/s<br>
          ${isNearEquilibrium ? '<span style="color:var(--success)">‚úì CERCA DEL EQUILIBRIO</span>' : 'En movimiento'}
          ${this.damping > 1.0 && totalVel < 0.01 ? '<br><span style="color:var(--success)">‚úì EN REPOSO</span>' : ''}
          ${this.audioEnabled && totalVel > 0.1 ? '<br><span style="color:var(--audio)">üéµ AUDIO TONAL ACTIVO</span>' : ''}
          ${this.percussionEnabled && totalVel > 0.1 ? '<br><span style="color:var(--audio)">ü•Å PERCUSI√ìN ACTIVA</span>' : ''}
        `;
      }

      draw() {
        this.ctx.clearRect(0, 0, this.width, this.height);
        this.drawGridAndAxes();
        this.drawTraces();
        this.drawPendulum();
        this.drawInfo();
      }

      drawGridAndAxes() {
        this.ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--grid');
        this.ctx.lineWidth = 1;
        const step = 40;
        for (let x = 0; x <= this.width; x += step) {
          this.ctx.beginPath(); this.ctx.moveTo(x, 0); this.ctx.lineTo(x, this.height); this.ctx.stroke();
        }
        for (let y = 0; y <= this.height; y += step) {
          this.ctx.beginPath(); this.ctx.moveTo(0, y); this.ctx.lineTo(this.width, y); this.ctx.stroke();
        }
        
        this.ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--axis');
        this.ctx.lineWidth = 2;
        this.ctx.beginPath(); this.ctx.moveTo(this.originX, 0); this.ctx.lineTo(this.originX, this.height); this.ctx.stroke();
        this.ctx.beginPath(); this.ctx.moveTo(0, this.originY); this.ctx.lineTo(this.width, this.originY); this.ctx.stroke();
        
        // Origen destacado
        this.ctx.fillStyle = '#4a9eff';
        this.ctx.beginPath(); this.ctx.arc(this.originX, this.originY, 5, 0, Math.PI*2); this.ctx.fill();
        this.ctx.fillStyle = '#ffffff';
        this.ctx.beginPath(); this.ctx.arc(this.originX, this.originY, 2, 0, Math.PI*2); this.ctx.fill();
      }

      drawTraces() {
        if (this.trace1.length > 1) {
          this.ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--trace1');
          this.ctx.lineWidth = 1.5; 
          this.ctx.globalAlpha = 0.7;
          this.ctx.beginPath(); 
          this.ctx.moveTo(this.trace1[0].x, this.trace1[0].y);
          for (let i = 1; i < this.trace1.length; i++) this.ctx.lineTo(this.trace1[i].x, this.trace1[i].y);
          this.ctx.stroke();
        }
        if (this.trace2.length > 1) {
          this.ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--trace2');
          this.ctx.lineWidth = 2.5; 
          this.ctx.globalAlpha = 0.9;
          this.ctx.beginPath(); 
          this.ctx.moveTo(this.trace2[0].x, this.trace2[0].y);
          for (let i = 1; i < this.trace2.length; i++) this.ctx.lineTo(this.trace2[i].x, this.trace2[i].y);
          this.ctx.stroke();
        }
        this.ctx.globalAlpha = 1.0;
      }

      drawPendulum() {
        const p1 = this.getPendulumPosition(1);
        const p2 = this.getPendulumPosition(2);
        
        // Barras
        this.ctx.strokeStyle = '#ffffff'; this.ctx.lineWidth = 4;
        this.ctx.beginPath(); this.ctx.moveTo(this.originX, this.originY); this.ctx.lineTo(p1.x, p1.y); this.ctx.stroke();
        this.ctx.beginPath(); this.ctx.moveTo(p1.x, p1.y); this.ctx.lineTo(p2.x, p2.y); this.ctx.stroke();

        // Masas con tama√±o proporcional
        const radius1 = Math.max(6, 4 + this.m1*4);
        const radius2 = Math.max(6, 4 + this.m2*4);
        
        // üéµ Efectos visuales de audio
        let color1 = getComputedStyle(document.documentElement).getPropertyValue('--trace1');
        let color2 = getComputedStyle(document.documentElement).getPropertyValue('--trace2');
        
        if (this.audioEnabled && this.running) {
          // Intensidad visual basada en frecuencia
          const intensity1 = Math.min(1, Math.abs(this.omega1) * 0.2);
          const intensity2 = Math.min(1, Math.abs(this.omega2) * 0.2);
          
          if (intensity1 > 0.1) {
            this.ctx.shadowBlur = 15 * intensity1;
            this.ctx.shadowColor = color1;
          }
        }
        
        this.ctx.fillStyle = color1;
        this.ctx.beginPath(); this.ctx.arc(p1.x, p1.y, radius1, 0, Math.PI*2); this.ctx.fill();
        this.ctx.strokeStyle = '#ffffff'; this.ctx.lineWidth = 2;
        this.ctx.beginPath(); this.ctx.arc(p1.x, p1.y, radius1, 0, Math.PI*2); this.ctx.stroke();
        
        if (this.audioEnabled && this.running) {
          const intensity2 = Math.min(1, Math.abs(this.omega2) * 0.2);
          if (intensity2 > 0.1) {
            this.ctx.shadowBlur = 15 * intensity2;
            this.ctx.shadowColor = color2;
          }
        }
        
        this.ctx.fillStyle = color2;
        this.ctx.beginPath(); this.ctx.arc(p2.x, p2.y, radius2, 0, Math.PI*2); this.ctx.fill();
        this.ctx.strokeStyle = '#ffffff'; this.ctx.lineWidth = 2;
        this.ctx.beginPath(); this.ctx.arc(p2.x, p2.y, radius2, 0, Math.PI*2); this.ctx.stroke();
        
        // Reset shadow
        this.ctx.shadowBlur = 0;
      }

      drawInfo() {
        this.ctx.fillStyle = '#4a9eff'; this.ctx.font = '13px Consolas';
        this.ctx.fillText(`Œ∏‚ÇÅ: ${this.theta1.toFixed(3)} rad`, 10, 20);
        this.ctx.fillText(`Œ∏‚ÇÇ: ${this.theta2.toFixed(3)} rad`, 10, 36);
        this.ctx.fillText(`œâ‚ÇÅ: ${this.omega1.toFixed(3)} rad/s`, 10, 52);
        this.ctx.fillText(`œâ‚ÇÇ: ${this.omega2.toFixed(3)} rad/s`, 10, 68);
        
        // üéµ Indicadores de audio
        let yOffset = 84;
        if (this.audioEnabled && this.running) {
          this.ctx.fillStyle = '#ff9500';
          this.ctx.fillText(`‚ô™1: ${this.currentFreq1.toFixed(0)} Hz`, 10, yOffset);
          this.ctx.fillText(`‚ô™2: ${this.currentFreq2.toFixed(0)} Hz`, 10, yOffset + 16);
          yOffset += 32;
        }
        
        // ü•Å Indicadores de percusi√≥n
        if (this.percussionEnabled && this.running) {
          this.ctx.fillStyle = '#ff6b4a';
          this.ctx.fillText(`ü•Å: ${this.kickCount} golpes`, 10, yOffset);
          this.ctx.fillStyle = '#4aff6b';
          this.ctx.fillText(`üîî: ${this.snareCount} golpes`, 10, yOffset + 16);
          yOffset += 32;
        }
        
        if (this.damping > 0) {
          this.ctx.fillStyle = this.damping > 1.0 ? '#ff6b4a' : '#ffaa4a';
          this.ctx.fillText(`Fricci√≥n: ${this.damping.toFixed(2)}`, 10, yOffset);
          yOffset += 16;
        }
        
        this.ctx.fillStyle = '#888';
        this.ctx.font = '11px Consolas';
        this.ctx.fillText(`Escala: ${this.scale.toFixed(1)} px/m`, 10, this.height - 10);
      }

      start() { 
        if (!this.running) { 
          this.running = true; 
          this.initialEnergy = this.computeEnergy();
          this.maxEnergyDrift = 0;
          this.animate(); 
        } 
      }
      
      stop() { 
        this.running = false;
        // üéµ Silenciar audio al parar
        if (this.audioEnabled) {
          this.gainNode1.gain.setTargetAtTime(0, this.audioContext.currentTime, 0.1);
          this.gainNode2.gain.setTargetAtTime(0, this.audioContext.currentTime, 0.1);
        }
      }
      
      reset() {
        this.stop();
        // Volver a posici√≥n vertical hacia ARRIBA (12h del reloj)
        this.theta1 = Math.PI; this.theta2 = -0.01;
        this.omega1 = 0; this.omega2 = 0;
        this.time = 0; this.clearTraces();
        this.initialEnergy = this.computeEnergy();
        this.currentEnergy = this.initialEnergy;
        this.maxEnergyDrift = 0;
        this.energyHistory = [];
        this.singularityCount = 0;
        
        // ü•Å RESETEAR CONTADORES DE PERCUSI√ìN
        this.kickCount = 0;
        this.snareCount = 0;
        this.lastTrigger1 = 0;
        this.lastTrigger2 = 0;
        this.lastOmega1 = 0;
        this.lastOmega2 = 0;
        this.omega1Trend = 0;
        this.omega2Trend = 0;
        
        this.updateCanvasMetrics(); this.draw();
      }
      
      clearTraces() { 
        this.trace1 = []; this.trace2 = []; 
        if (!this.running) this.draw(); 
      }

      animate() {
        if (!this.running) return;
        this.update();
        this.draw();
        requestAnimationFrame(() => this.animate());
      }
    }

    // Inicializaci√≥n del simulador musical
    const pendulum = new MusicalDoublePendulum('pendulumCanvas', 'simPanel');
    
    // Mensaje de bienvenida
    console.log('üéµ Doble P√©ndulo Musical iniciado!');
    console.log('Activa el audio para escuchar el caos convertido en m√∫sica');
  </script>
</body>
</html>